import xml.etree.ElementTree as ET
from lxml import etree
import pydiffvg
import torch
import re
import io
from PIL import Image
import cairosvg


def convert_svg_floats_to_ints(svg_content):
    # Parse SVG from string
    root = ET.fromstring(svg_content)
    
    # Define a regular expression to find floating-point numbers
    # This pattern matches numbers like 1.23, -0.45, .67, etc.
    float_pattern = re.compile(r'(-?\d*\.\d+|-?\.\d+)')
    
    # Function to replace floats with integers in a string
    def replace_floats_with_ints(text):
        if text is None:
            return None
        
        def replace_float(match):
            float_val = float(match.group(0))
            int_val = round(float_val)
            return str(int_val)
        
        return float_pattern.sub(replace_float, text)
    
    # Find all elements and process their attributes
    for elem in root.iter():
        for attr_name, attr_value in elem.attrib.items():
            # For path data and other numerical attributes
            elem.attrib[attr_name] = replace_floats_with_ints(attr_value)
    
    # Convert the modified SVG back to string
    output = io.StringIO()
    tree = ET.ElementTree(root)
    tree.write(output, encoding='unicode', xml_declaration=True)
    return output.getvalue()


def optimize_svg_paths(svg_content):
    # Parse SVG from string
    root = ET.fromstring(svg_content)
    
    # Process all path elements
    for elem in root.iter():
        if elem.tag.endswith('path'):
            if 'd' in elem.attrib:
                path_data = elem.attrib['d']
                
                # Replace spaces between commands and coordinates with commas
                # First, identify path commands (M, L, H, V, C, S, Q, T, A, Z)
                path_pattern = re.compile(r'([MLHVCSQTAZ])[\s]+([^MLHVCSQTAZ]+)', re.IGNORECASE)
                
                def replace_space_with_comma(match):
                    command = match.group(1)
                    coords = match.group(2).strip()
                    # Replace spaces with commas in coordinates
                    coords = re.sub(r'\s+', ',', coords)
                    return f"{command}{coords}"
                
                optimized_path = path_pattern.sub(replace_space_with_comma, path_data)
                
                # Remove spaces between consecutive coordinates
                optimized_path = re.sub(r'([0-9])\s+([0-9-])', r'\1,\2', optimized_path)
                
                # Handle consecutive commands by ensuring no space between them
                optimized_path = re.sub(r'([MLHVCSQTAZ])\s+([MLHVCSQTAZ])', r'\1\2', optimized_path, flags=re.IGNORECASE)
                
                elem.attrib['d'] = optimized_path
    
    # Convert the modified SVG back to string
    output = io.StringIO()
    tree = ET.ElementTree(root)
    tree.write(output, encoding='unicode', xml_declaration=True)
    return output.getvalue()



def minify_svg(svg_content):
    # Remove line breaks and unnecessary whitespace between tags
    # Preserve space in text content but remove between tags
    svg_content = re.sub(r'>\s+<', '><', svg_content)
    
    # Remove whitespace at the beginning and end of the file
    svg_content = svg_content.strip()
    
    # Compress whitespace in attribute values (preserving spaces in actual content)
    svg_content = re.sub(r'\s{2,}', ' ', svg_content)

    text_content = '''"http://www.w3.org/2000/svg" version="1"'''
    new_text_content = '''"http://www.w3.org/2000/svg" viewBox="0 0 384 384"'''
    svg_content = svg_content.replace(text_content, new_text_content)
    
    return svg_content


def fix_xml_svg(svg_string):
    """Fix issues with SVG XML generated by pydiffvg."""
    # Parse the SVG XML
    root = etree.fromstring(svg_string)
    
    # Add viewBox attribute if width and height exist but viewBox doesn't
    if root.tag.endswith('svg'):
        width = root.get('width')
        height = root.get('height')
        
        if width is not None and height is not None and root.get('viewBox') is None:
            # Extract numeric values from width/height (removing 'px', etc.)
            width_value = re.search(r'(\d+)', width)
            height_value = re.search(r'(\d+)', height)
            
            if width_value and height_value:
                width_num = width_value.group(1)
                height_num = height_value.group(1)
                root.set('viewBox', f"0 0 {width_num} {height_num}")

    # Function to clean up style attributes
    def clean_style(element):
        style = element.attrib.get('style', '')
        if style:
            # Parse the style attribute
            style_dict = dict(item.split(':') for item in style.split(';') if item and ':' in item)
            # Remove the style attribute
            if 'style' in element.attrib:
                del element.attrib['style']
            # Apply styles as regular attributes
            for key, value in style_dict.items():
                element.attrib[key.strip()] = value.strip()

    # Function to clean number values, removing trailing dots
    def clean_number(value):
        if isinstance(value, str):
            # Remove tensor references
            if 'tensor' in value:
                tensor_match = re.search(r'tensor\(([^,\)]+)', value)
                if tensor_match:
                    value = tensor_match.group(1).strip()
            
            # Remove trailing dots from numbers
            if value.endswith('.'):
                try:
                    # Only remove the dot if it's actually a number
                    float(value)
                    return value[:-1]
                except ValueError:
                    pass
        return value

    # Process all elements in the SVG
    for elem in root.iter():
        # Clean all attributes
        for key, value in list(elem.attrib.items()):
            # Skip xmlns attributes
            if key.startswith('xmlns'):
                continue
                
            # Clean number values and tensor references
            clean_value = clean_number(value)
            
            # Update the attribute
            if clean_value != value:
                elem.attrib[key] = clean_value
            
            # Remove empty attributes
            if value == "":
                del elem.attrib[key]
        
        # Clean up style attributes
        clean_style(elem)
    
    # Special handling for transform attributes
    for element in root.xpath("//*[@transform]"):
        transform = element.attrib['transform']
        # Clean tensor references in transforms
        if 'tensor' in transform:
            # Extract contents inside the transform function
            match = re.search(r'(translate|scale|rotate|matrix)\((.*?)\)', transform)
            if match:
                transform_type = match.group(1)
                values = match.group(2)
                
                # Clean tensor references in values
                cleaned_values = re.sub(r'tensor\(([^,\)]+).*?\)', r'\1', values)
                
                # Clean trailing dots
                cleaned_values = ' '.join([clean_number(v) for v in cleaned_values.split()])
                
                # Reconstruct the transform
                element.attrib['transform'] = f"{transform_type}({cleaned_values})".strip()

    # Return the modified SVG as a string
    return etree.tostring(root, pretty_print=True, encoding='utf-8').decode('utf-8')


def optimize_svg(svg):
    svg = fix_xml_svg(svg)
    svg = convert_svg_floats_to_ints(svg)
    svg = optimize_svg_paths(svg)
    svg = minify_svg(svg)

    svg = svg.replace("version='1.0'", "").replace('version="1.0"', "")
    svg = svg.replace("version='2.0'", "").replace('version="2.0"', "")
    svg = svg.replace('transform=" ', 'transform="')
    
    # svg = svg.replace('stroke-width="1"', '')
    # svg = svg.replace('stroke-width="2"', '')
    
    return svg



def svg_to_png(svg_code: str, size: tuple = (384, 384)) -> Image.Image:
    if 'viewBox' not in svg_code:
        svg_code = svg_code.replace(
            '<svg', f'<svg viewBox="0 0 {size[0]} {size[1]}"'
        )

    png_data = cairosvg.svg2png(bytestring=svg_code.encode('utf-8'))
    return Image.open(io.BytesIO(png_data)).convert('RGB').resize(size)


def validate_svg(svg, validator):
    temp_path = "/tmp/temp.svg"
    
    with open(temp_path, "w") as f:
        f.write(svg)

    canvas_width, canvas_height, shapes, shape_groups = svg_to_scene_with_rect_conversion(temp_path)

    pydiffvg.save_svg(temp_path, canvas_width, canvas_height, shapes, shape_groups)

    with open(temp_path) as f:
        svg = f.read()

    svg = optimize_svg(svg)
    valid = True

    try:
        validator.validate_svg(svg)
    except:
        valid = False

    return valid


if __name__ == "__main__":
    with open('output.svg') as f:
        svg_org = f.read()
    
    svg_opt = optimize_svg(svg_org)

    with open('output_opt5.svg', 'w') as f:
        f.write(svg_opt)

    print(len(svg_org.encode('utf-8')))
    print(len(svg_opt.encode('utf-8')))



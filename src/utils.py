import xml.etree.ElementTree as ET
import random
import numpy as np
from lxml import etree
import pydiffvg
import torch
import re
import io
from PIL import Image
import cairosvg
import scour.scour
import svgpathtools
import svgpathtools
from svgpathtools import document, wsvg
import math
from svgpathtools import Path, Line, CubicBezier, QuadraticBezier, Arc
from picosvg.svg import SVG



def convert_svg_floats_to_ints(svg_content):
    # Parse SVG from string
    root = ET.fromstring(svg_content)
    
    # Define a regular expression to find floating-point numbers
    # This pattern matches numbers like 1.23, -0.45, .67, etc.
    float_pattern = re.compile(r'(-?\d*\.\d+|-?\.\d+)')
    
    # Function to replace floats with integers in a string
    def replace_floats_with_ints(text):
        if text is None:
            return None
        
        def replace_float(match):
            float_val = float(match.group(0))
            int_val = round(float_val)
            return str(int_val)
        
        return float_pattern.sub(replace_float, text)
    
    # Find all elements and process their attributes
    for elem in root.iter():
        for attr_name, attr_value in elem.attrib.items():
            # For path data and other numerical attributes
            elem.attrib[attr_name] = replace_floats_with_ints(attr_value)
    
    # Convert the modified SVG back to string
    output = io.StringIO()
    tree = ET.ElementTree(root)
    tree.write(output, encoding='unicode', xml_declaration=True)
    return output.getvalue()


def optimize_svg_paths(svg_content):
    # Parse SVG from string
    root = ET.fromstring(svg_content)
    
    # Process all path elements
    for elem in root.iter():
        if elem.tag.endswith('path'):
            if 'd' in elem.attrib:
                path_data = elem.attrib['d']
                
                # Replace spaces between commands and coordinates with commas
                # First, identify path commands (M, L, H, V, C, S, Q, T, A, Z)
                path_pattern = re.compile(r'([MLHVCSQTAZ])[\s]+([^MLHVCSQTAZ]+)', re.IGNORECASE)
                
                def replace_space_with_comma(match):
                    command = match.group(1)
                    coords = match.group(2).strip()
                    # Replace spaces with commas in coordinates
                    coords = re.sub(r'\s+', ',', coords)
                    return f"{command}{coords}"
                
                optimized_path = path_pattern.sub(replace_space_with_comma, path_data)
                
                # Remove spaces between consecutive coordinates
                optimized_path = re.sub(r'([0-9])\s+([0-9-])', r'\1,\2', optimized_path)
                
                # Handle consecutive commands by ensuring no space between them
                optimized_path = re.sub(r'([MLHVCSQTAZ])\s+([MLHVCSQTAZ])', r'\1\2', optimized_path, flags=re.IGNORECASE)
                
                elem.attrib['d'] = optimized_path
    
    # Convert the modified SVG back to string
    output = io.StringIO()
    tree = ET.ElementTree(root)
    tree.write(output, encoding='unicode', xml_declaration=True)
    return output.getvalue()



def minify_svg(svg_content):
    # Remove line breaks and unnecessary whitespace between tags
    # Preserve space in text content but remove between tags
    svg_content = re.sub(r'>\s+<', '><', svg_content)
    
    # Remove whitespace at the beginning and end of the file
    svg_content = svg_content.strip()
    
    # Compress whitespace in attribute values (preserving spaces in actual content)
    svg_content = re.sub(r'\s{2,}', ' ', svg_content)

    text_content = '''"http://www.w3.org/2000/svg" version="1"'''
    new_text_content = '''"http://www.w3.org/2000/svg" viewBox="0 0 384 384"'''
    svg_content = svg_content.replace(text_content, new_text_content)
    
    return svg_content


def fix_xml_svg(svg_string):
    """Fix issues with SVG XML generated by pydiffvg."""
    # Parse the SVG XML
    root = etree.fromstring(svg_string)
    
    # Add viewBox attribute if width and height exist but viewBox doesn't
    if root.tag.endswith('svg'):
        width = root.get('width')
        height = root.get('height')
        
        if width is not None and height is not None and root.get('viewBox') is None:
            # Extract numeric values from width/height (removing 'px', etc.)
            width_value = re.search(r'(\d+)', width)
            height_value = re.search(r'(\d+)', height)
            
            if width_value and height_value:
                width_num = width_value.group(1)
                height_num = height_value.group(1)
                root.set('viewBox', f"0 0 {width_num} {height_num}")

    # Function to clean up style attributes
    def clean_style(element):
        style = element.attrib.get('style', '')
        if style:
            # Parse the style attribute
            style_dict = dict(item.split(':') for item in style.split(';') if item and ':' in item)
            # Remove the style attribute
            if 'style' in element.attrib:
                del element.attrib['style']
            # Apply styles as regular attributes
            for key, value in style_dict.items():
                element.attrib[key.strip()] = value.strip()

    # Function to clean number values, removing trailing dots
    def clean_number(value):
        if isinstance(value, str):
            # Remove tensor references
            if 'tensor' in value:
                tensor_match = re.search(r'tensor\(([^,\)]+)', value)
                if tensor_match:
                    value = tensor_match.group(1).strip()
            
            # Remove trailing dots from numbers
            if value.endswith('.'):
                try:
                    # Only remove the dot if it's actually a number
                    float(value)
                    return value[:-1]
                except ValueError:
                    pass
        return value

    # Process all elements in the SVG
    for elem in root.iter():
        # Clean all attributes
        for key, value in list(elem.attrib.items()):
            # Skip xmlns attributes
            if key.startswith('xmlns'):
                continue
                
            # Clean number values and tensor references
            clean_value = clean_number(value)
            
            # Update the attribute
            if clean_value != value:
                elem.attrib[key] = clean_value
            
            # Remove empty attributes
            if value == "":
                del elem.attrib[key]
        
        # Clean up style attributes
        clean_style(elem)
    
    # Special handling for transform attributes
    for element in root.xpath("//*[@transform]"):
        transform = element.attrib['transform']
        # Clean tensor references in transforms
        if 'tensor' in transform:
            # Extract contents inside the transform function
            match = re.search(r'(translate|scale|rotate|matrix)\((.*?)\)', transform)
            if match:
                transform_type = match.group(1)
                values = match.group(2)
                
                # Clean tensor references in values
                cleaned_values = re.sub(r'tensor\(([^,\)]+).*?\)', r'\1', values)
                
                # Clean trailing dots
                cleaned_values = ' '.join([clean_number(v) for v in cleaned_values.split()])
                
                # Reconstruct the transform
                element.attrib['transform'] = f"{transform_type}({cleaned_values})".strip()

    # Return the modified SVG as a string
    return etree.tostring(root, pretty_print=True, encoding='utf-8').decode('utf-8')


def optimize_svg_picosvg(svg):
    svg_instance = SVG.fromstring(svg)
    svg_instance.topicosvg(inplace=True)
    return svg_instance.tostring(pretty_print=False)

def optimize_svg(svg, use_picosvg=False):
    if use_picosvg:
        svg = optimize_svg_picosvg(svg)

    # Then, use scour for further minification
    options = scour.scour.parse_args([
        '--enable-viewboxing',
        '--enable-id-stripping',
        '--enable-comment-stripping',
        '--shorten-ids',
        '--indent=none',
        '--strip-xml-prolog',
        '--remove-metadata',
        '--remove-descriptive-elements',
        '--disable-embed-rasters',
        # '--enable-viewboxing',
        '--create-groups',
        '--renderer-workaround',
        '--set-precision=2',  # Set decimal precision to 2 places
    ])

    svg = scour.scour.scourString(svg, options)
    
    svg = svg.replace('id=""', '')
    svg = svg.replace('  ', ' ')
    svg = svg.replace('>\n', '>')

    # svg = re.sub(r' id=".*?"', '', svg)
    # svg = re.sub(r'>\n', '>', svg)

    
    # # If opacity is provided, apply it globally and remove individual opacity attributes
    # if opacity is not None:
    #     # Parse the SVG
    #     root = ET.fromstring(svg)
        
    #     # Find the topmost g tag with the scaling transform
    #     for g_elem in root.findall(".//g"):
    #         if "transform" in g_elem.attrib and "scale" in g_elem.attrib["transform"]:
    #             # Add the opacity to this g element
    #             g_elem.set("fill-opacity", str(opacity))
                
    #             # Remove all individual fill-opacity attributes from descendants
    #             for elem in g_elem.iter():
    #                 if "fill-opacity" in elem.attrib:
    #                     del elem.attrib["fill-opacity"]
                
    #             # Convert back to string
    #             svg = ET.tostring(root, encoding='unicode')
    #             break
    
    return svg



def svg_to_png(svg_code: str, size: tuple = (384, 384)) -> Image.Image:
    if 'viewBox' not in svg_code:
        svg_code = svg_code.replace(
            '<svg', f'<svg viewBox="0 0 {size[0]} {size[1]}"'
        )

    png_data = cairosvg.svg2png(bytestring=svg_code.encode('utf-8'))
    return Image.open(io.BytesIO(png_data)).convert('RGB').resize(size)


def validate_svg(svg, validator):
    temp_path = "/tmp/temp.svg"
    
    with open(temp_path, "w") as f:
        f.write(svg)

    canvas_width, canvas_height, shapes, shape_groups = svg_to_scene_with_rect_conversion(temp_path)

    pydiffvg.save_svg(temp_path, canvas_width, canvas_height, shapes, shape_groups)

    with open(temp_path) as f:
        svg = f.read()

    svg = optimize_svg(svg)
    valid = True

    try:
        validator.validate_svg(svg)
    except:
        valid = False

    return valid


def create_random_svg(
    canvas_width,
    canvas_height,
    num_paths=10,
    use_blob=False,
    add_background=True,
    num_grid_cells=4
):
    """Create a random SVG string with paths, possibly using a checkerboard pattern."""
    # Set up the SVG content
    svg = f'<svg width="{canvas_width}" height="{canvas_height}" xmlns="http://www.w3.org/2000/svg">\n'
    
    # Add a background rectangle if requested
    if add_background:
        bg_fill = "url(#gradient)" if random.random() > 0.5 else "#" + ''.join([random.choice('0123456789ABCDEF') for _ in range(6)])
        svg += f'  <rect width="{canvas_width}" height="{canvas_height}" fill="{bg_fill}" />\n'
    
    # Add a gradient definition
    svg += '  <defs>\n'
    svg += '    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">\n'
    svg += f'      <stop offset="0%" style="stop-color:rgb({random.randint(0,255)},{random.randint(0,255)},{random.randint(0,255)});stop-opacity:1" />\n'
    svg += f'      <stop offset="100%" style="stop-color:rgb({random.randint(0,255)},{random.randint(0,255)},{random.randint(0,255)});stop-opacity:1" />\n'
    svg += '    </linearGradient>\n'
    svg += '  </defs>\n'
    
    # Create shapes based on the requested parameters
    if random.random() > 0.5 and num_grid_cells > 0:
        # Create a checkerboard pattern
        cell_width = canvas_width / num_grid_cells
        cell_height = canvas_height / num_grid_cells
        
        for i in range(num_grid_cells):
            for j in range(num_grid_cells):
                if (i + j) % 2 == 0:  # Checkerboard pattern
                    x = i * cell_width
                    y = j * cell_height
                    fill = "#" + ''.join([random.choice('0123456789ABCDEF') for _ in range(6)])
                    
                    if use_blob:
                        # Create a random blob with bezier curves
                        points = []
                        cx, cy = x + cell_width/2, y + cell_height/2
                        r = min(cell_width, cell_height) * 0.4
                        num_points = random.randint(5, 8)
                        
                        for k in range(num_points):
                            angle = 2 * np.pi * k / num_points
                            px = cx + r * np.cos(angle) * (0.8 + 0.4 * random.random())
                            py = cy + r * np.sin(angle) * (0.8 + 0.4 * random.random())
                            points.append(f"{px},{py}")
                        
                        svg += f'  <polygon points="{" ".join(points)}" fill="{fill}" />\n'
                    else:
                        # Create a simple rectangle
                        svg += f'  <rect x="{x}" y="{y}" width="{cell_width}" height="{cell_height}" fill="{fill}" />\n'
    
    # Add random paths
    for _ in range(num_paths):
        if use_blob:
            # Create closed paths with fills
            cx, cy = random.uniform(0, canvas_width), random.uniform(0, canvas_height)
            r = random.uniform(10, min(canvas_width, canvas_height) * 0.2)
            num_points = random.randint(5, 10)
            d = "M"
            
            for i in range(num_points):
                angle = 2 * np.pi * i / num_points
                radius = r * (0.7 + 0.6 * random.random())  # Vary the radius for organic shapes
                px = cx + radius * np.cos(angle)
                py = cy + radius * np.sin(angle)
                
                if i == 0:
                    d += f" {px},{py}"
                else:
                    # Use bezier curves for more organic shapes
                    cp1x = prev_x + (px - prev_x) * 0.5 + random.uniform(-r*0.2, r*0.2)
                    cp1y = prev_y + (py - prev_y) * 0.5 + random.uniform(-r*0.2, r*0.2)
                    d += f" C {cp1x},{cp1y} {cp1x},{cp1y} {px},{py}"
                
                prev_x, prev_y = px, py
            
            # Close the path
            d += " Z"
            fill = "#" + ''.join([random.choice('0123456789ABCDEF') for _ in range(6)])
            svg += f'  <path d="{d}" fill="{fill}" />\n'
        else:
            # Create open paths with strokes
            num_points = random.randint(3, 7)
            d = "M"
            x, y = random.uniform(0, canvas_width), random.uniform(0, canvas_height)
            
            for i in range(num_points):
                if i == 0:
                    d += f" {x},{y}"
                else:
                    # Add random offsets to create a flowing line
                    x += random.uniform(-40, 40)
                    y += random.uniform(-40, 40)
                    d += f" L {x},{y}"
            
            stroke = "#" + ''.join([random.choice('0123456789ABCDEF') for _ in range(6)])
            stroke_width = random.uniform(1, 10)
            svg += f'  <path d="{d}" stroke="{stroke}" stroke-width="{stroke_width}" fill="none" />\n'
    
    svg += '</svg>'
    return svg


def displace_svg_paths(svg, x_offset = 0, y_offset = 0, scale=0.5) -> str:
    temp_path = "/tmp/temp.svg"
    with open(temp_path, "w") as f:
        f.write(svg)
    
    paths, attributes, svg_attributes = svgpathtools.svg2paths2(temp_path)
    displacement = complex(x_offset, y_offset)
    
    for i, path in enumerate(paths):
        paths[i] = path.scaled(scale).translated(displacement)

    wsvg(paths, attributes=attributes, svg_attributes=svg_attributes, filename=temp_path)

    with open(temp_path) as f:
        svg = f.read()
    
    svg = svg.replace("<defs/>\n", "")

    return svg


if __name__ == "__main__":
    with open('output.svg') as f:
        svg_org = f.read()
    
    svg_opt = optimize_svg(svg_org)

    with open('output_opt.svg', 'w') as f:
        f.write(svg_opt)

    print(len(svg_org.encode('utf-8')))
    print(len(svg_opt.encode('utf-8')))

